{"version":3,"file":"session.cjs","sources":["../../src/session/session.ts","../../src/session/storageBackend.ts","../../src/session/storage.ts"],"sourcesContent":["import type { Session as AuthSession } from '../auth';\n\n/**\n * Decoded JWT token payload with processed timestamps and Hasura claims\n */\nexport interface DecodedToken {\n  /** Token expiration time as Date object */\n  exp?: number;\n  /** Token issued at time as Date object */\n  iat?: number;\n  /** Token issuer */\n  iss?: string;\n  /** Token subject (user ID) */\n  sub?: string;\n  /** Hasura JWT claims with PostgreSQL arrays converted to JavaScript arrays */\n  'https://hasura.io/jwt/claims'?: Record<string, unknown>;\n  /** Any other JWT claims */\n  [key: string]: unknown;\n}\n\nexport interface Session extends AuthSession {\n  /** Decoded JWT token payload with processed timestamps and Hasura claims */\n  decodedToken: DecodedToken;\n}\n\n/**\n * Decodes a base64url-encoded string (RFC 4648 Section 5) to a UTF-8 string.\n *\n * JWTs use base64url encoding, which differs from standard base64 by using\n * `-` and `_` instead of `+` and `/`, and omitting padding. The browser's\n * native `atob()` does not support base64url, so we must handle the conversion.\n */\nconst decodeBase64Url = (input: string): string => {\n  // Convert base64url to standard base64\n  let base64 = input.replace(/-/g, '+').replace(/_/g, '/');\n  const pad = base64.length % 4;\n  if (pad) {\n    base64 += '='.repeat(4 - pad);\n  }\n\n  // Use TextDecoder for proper UTF-8 support (atob alone mangles multi-byte characters)\n  const binaryString = atob(base64);\n  const bytes = Uint8Array.from(binaryString, (c) => c.charCodeAt(0));\n  return new TextDecoder().decode(bytes);\n};\n\nexport const decodeUserSession = (accessToken: string): DecodedToken => {\n  const s = accessToken.split('.');\n  if (s.length !== 3 || !s[1]) {\n    throw new Error('Invalid access token format');\n  }\n\n  const decodedToken = JSON.parse(decodeBase64Url(s[1])) as Record<\n    string,\n    unknown\n  >;\n\n  // Convert iat and exp to Date objects\n  const iat =\n    typeof decodedToken['iat'] === 'number'\n      ? decodedToken['iat'] * 1000 // Convert seconds to milliseconds\n      : undefined;\n  const exp =\n    typeof decodedToken['exp'] === 'number'\n      ? decodedToken['exp'] * 1000 // Convert seconds to milliseconds\n      : undefined;\n\n  // Process Hasura claims - dynamically convert PostgreSQL array notation to arrays\n  const hasuraClaims = decodedToken['https://hasura.io/jwt/claims'] as\n    | Record<string, unknown>\n    | undefined;\n  const processedClaims = hasuraClaims\n    ? Object.entries(hasuraClaims).reduce(\n        (acc, [key, value]) => {\n          if (typeof value === 'string' && isPostgresArray(value)) {\n            acc[key] = parsePostgresArray(value);\n          } else {\n            acc[key] = value;\n          }\n          return acc;\n        },\n        {} as Record<string, unknown>,\n      )\n    : undefined;\n\n  return {\n    ...decodedToken,\n    iat,\n    exp,\n    'https://hasura.io/jwt/claims': processedClaims,\n  };\n};\n\nconst isPostgresArray = (value: string): boolean => {\n  return value.startsWith('{') && value.endsWith('}');\n};\n\nconst parsePostgresArray = (value: string): string[] => {\n  if (!value || value === '{}') return [];\n  // Remove curly braces and split by comma, handling quoted values\n  return value\n    .slice(1, -1)\n    .split(',')\n    .map((item) => item.trim().replace(/^\"(.*)\"$/, '$1'));\n};\n","/**\n * Storage implementations for session persistence in different environments.\n *\n * This module provides different storage adapters for persisting authentication sessions\n * across page reloads and browser sessions.\n */\n\nimport type { Session } from './session';\n\n/**\n * Session storage interface for session persistence.\n * This interface can be implemented to provide custom storage solutions.\n */\nexport interface SessionStorageBackend {\n  /**\n   * Get the current session from storage\n   * @returns The stored session or null if not found\n   */\n  get(): Session | null;\n\n  /**\n   * Set the session in storage\n   * @param value - The session to store\n   */\n  set(value: Session): void;\n\n  /**\n   * Remove the session from storage\n   */\n  remove(): void;\n}\n\n/**\n * Default storage key used for storing the Nhost session\n */\nexport const DEFAULT_SESSION_KEY = 'nhostSession';\n\n/**\n * Browser localStorage implementation of StorageInterface.\n * Persists the session across page reloads and browser restarts.\n */\nexport class LocalStorage implements SessionStorageBackend {\n  private readonly storageKey: string;\n\n  /**\n   * Creates a new LocalStorage instance\n   * @param options - Configuration options\n   * @param options.storageKey - The key to use in localStorage (defaults to \"nhostSession\")\n   */\n  constructor(options?: { storageKey?: string }) {\n    this.storageKey = options?.storageKey || DEFAULT_SESSION_KEY;\n  }\n\n  /**\n   * Gets the session from localStorage\n   * @returns The stored session or null if not found\n   */\n  get(): Session | null {\n    try {\n      const value = window.localStorage.getItem(this.storageKey);\n      return value ? (JSON.parse(value) as Session) : null;\n    } catch {\n      this.remove();\n      return null;\n    }\n  }\n\n  /**\n   * Sets the session in localStorage\n   * @param value - The session to store\n   */\n  set(value: Session): void {\n    window.localStorage.setItem(this.storageKey, JSON.stringify(value));\n  }\n\n  /**\n   * Removes the session from localStorage\n   */\n  remove(): void {\n    window.localStorage.removeItem(this.storageKey);\n  }\n}\n\n/**\n * In-memory storage implementation for non-browser environments or when\n * persistent storage is not available or desirable.\n */\nexport class MemoryStorage implements SessionStorageBackend {\n  private session: Session | null = null;\n\n  /**\n   * Gets the session from memory\n   * @returns The stored session or null if not set\n   */\n  get(): Session | null {\n    return this.session;\n  }\n\n  /**\n   * Sets the session in memory\n   * @param value - The session to store\n   */\n  set(value: Session): void {\n    this.session = value;\n  }\n\n  /**\n   * Clears the session from memory\n   */\n  remove(): void {\n    this.session = null;\n  }\n}\n\n/**\n * Cookie-based storage implementation.\n * This storage uses web browser cookies to store the session so it's not\n * available in server-side environments. It is useful though for synchronizing\n * sessions between client and server environments.\n */\nexport class CookieStorage implements SessionStorageBackend {\n  private readonly cookieName: string;\n  private readonly expirationDays: number;\n  private readonly secure: boolean;\n  private readonly sameSite: 'strict' | 'lax' | 'none';\n\n  /**\n   * Creates a new CookieStorage instance\n   * @param options - Configuration options\n   * @param options.cookieName - Name of the cookie to use (defaults to \"nhostSession\")\n   * @param options.expirationDays - Number of days until the cookie expires (defaults to 30)\n   * @param options.secure - Whether to set the Secure flag on the cookie (defaults to true)\n   * @param options.sameSite - SameSite policy for the cookie (defaults to \"lax\")\n   */\n  constructor(options?: {\n    cookieName?: string;\n    expirationDays?: number;\n    secure?: boolean;\n    sameSite?: 'strict' | 'lax' | 'none';\n  }) {\n    this.cookieName = options?.cookieName || DEFAULT_SESSION_KEY;\n    this.expirationDays = options?.expirationDays ?? 30;\n    this.secure = options?.secure ?? true;\n    this.sameSite = options?.sameSite || 'lax';\n  }\n\n  /**\n   * Gets the session from cookies\n   * @returns The stored session or null if not found\n   */\n  get(): Session | null {\n    const cookies = document.cookie.split(';');\n    for (const cookie of cookies) {\n      const [name, value] = cookie.trim().split('=');\n      if (name === this.cookieName) {\n        try {\n          return JSON.parse(decodeURIComponent(value || '')) as Session;\n        } catch {\n          this.remove();\n          return null;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Sets the session in a cookie\n   * @param value - The session to store\n   */\n  set(value: Session): void {\n    const expires = new Date();\n    expires.setTime(\n      expires.getTime() + this.expirationDays * 24 * 60 * 60 * 1000,\n    );\n\n    const cookieValue = encodeURIComponent(JSON.stringify(value));\n    const cookieString = `${this.cookieName}=${cookieValue}; expires=${expires.toUTCString()}; path=/; ${this.secure ? 'secure; ' : ''}SameSite=${this.sameSite}`;\n\n    // biome-ignore lint/suspicious/noDocumentCookie: this is unnecessary\n    document.cookie = cookieString;\n  }\n\n  /**\n   * Removes the session cookie\n   */\n  remove(): void {\n    // biome-ignore lint/suspicious/noDocumentCookie: this is unnecessary\n    document.cookie = `${this.cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; ${this.secure ? 'secure; ' : ''}SameSite=${this.sameSite}`;\n  }\n}\n","/**\n * Storage implementations for session persistence in different environments.\n *\n * This module provides different storage adapters for persisting authentication sessions\n * across page reloads and browser sessions.\n */\n\nimport type { Session as AuthSession } from '../auth';\nimport { decodeUserSession, type Session } from './session';\nimport {\n  LocalStorage,\n  MemoryStorage,\n  type SessionStorageBackend,\n} from './storageBackend';\n\n/**\n * Callback function type for session change subscriptions\n */\nexport type SessionChangeCallback = (session: Session | null) => void;\n\n/**\n * A wrapper around any SessionStorageInterface implementation that adds\n * the ability to subscribe to session changes.\n */\nexport class SessionStorage {\n  private readonly storage: SessionStorageBackend;\n  private subscribers = new Set<SessionChangeCallback>();\n\n  /**\n   * Creates a new SessionStorage instance\n   * @param storage - The underlying storage implementation to use\n   */\n  constructor(storage: SessionStorageBackend) {\n    this.storage = storage;\n  }\n\n  /**\n   * Gets the session from the underlying storage\n   * @returns The stored session or null if not found\n   */\n  get(): Session | null {\n    return this.storage.get();\n  }\n\n  /**\n   * Sets the session in the underlying storage and notifies subscribers\n   * @param value - The session to store\n   */\n  set(value: AuthSession): void {\n    const decodedToken = decodeUserSession(value.accessToken);\n    const decodedSession = {\n      ...value,\n      decodedToken: decodedToken,\n    };\n\n    this.storage.set(decodedSession);\n    this.notifySubscribers(decodedSession);\n  }\n\n  /**\n   * Removes the session from the underlying storage and notifies subscribers\n   */\n  remove(): void {\n    this.storage.remove();\n    this.notifySubscribers(null);\n  }\n\n  /**\n   * Subscribe to session changes\n   * @param callback - Function that will be called when the session changes\n   * @returns An unsubscribe function to remove this subscription\n   */\n  onChange(callback: SessionChangeCallback) {\n    this.subscribers.add(callback);\n\n    return () => {\n      this.subscribers.delete(callback);\n    };\n  }\n\n  /**\n   * Notify all subscribers of a session change\n   * @param session - The new session value or null if removed\n   */\n  private notifySubscribers(session: Session | null): void {\n    for (const subscriber of this.subscribers) {\n      try {\n        subscriber(session);\n      } catch (error) {\n        console.error('Error notifying subscriber:', error);\n      }\n    }\n  }\n}\n\n/**\n * Detects the best available storage implementation for the current environment.\n *\n * The detection process follows this order:\n * 1. Try to use localStorage if we're in a browser environment\n * 2. Fall back to in-memory storage if localStorage isn't available\n *\n * @returns The best available storage implementation as a SessionStorageBackend\n */\nexport const detectStorage = (): SessionStorageBackend => {\n  if (typeof window !== 'undefined') {\n    return new LocalStorage();\n  }\n  return new MemoryStorage();\n};\n"],"names":["decodeUserSession","accessToken","s","split","length","Error","decodedToken","JSON","parse","input","base64","replace","pad","repeat","binaryString","atob","bytes","Uint8Array","from","c","charCodeAt","TextDecoder","decode","decodeBase64Url","iat","exp","hasuraClaims","processedClaims","Object","entries","reduce","acc","key","value","isPostgresArray","parsePostgresArray","startsWith","endsWith","slice","map","item","trim","DEFAULT_SESSION_KEY","LocalStorage","storageKey","constructor","options","this","get","window","localStorage","getItem","remove","set","setItem","stringify","removeItem","MemoryStorage","session","cookieName","expirationDays","secure","sameSite","cookies","document","cookie","name","decodeURIComponent","expires","Date","setTime","getTime","cookieValue","encodeURIComponent","cookieString","toUTCString","storage","subscribers","Set","decodedSession","notifySubscribers","onChange","callback","add","delete","subscriber","error","console"],"mappings":"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"}